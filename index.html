<!DOCTYPE HTML>
<html>
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
        <title>Chez Earth</title>
        <style type="text/css">
            body {
                margin: 0;
                overflow: hidden;
            }
            canvas {
                width: 100%;
                height: 100%;
            }
        </style>
    </head>
    <body>
        <script src="js/three.min.js"></script>
        <script src="js/OrbitControls.js"></script>
        <script id="vertex_shader" type="x-shader/x-vertex">
// Implicit attributes:
//  vec3 position   // The location of the vertex in object coords
//  vec3 normal     // The normal in object frame
//  vec2 uv         // The texture coords
// Implicit uniforms:
//  mat4 projectionMatrix   // From camera to "screen"
//  mat4 modelMatrix        // Object to world
//  mat4 viewMatrix         // World to camera
//  mat4 modelViewMatrix    // Object to camera
attribute vec4 tangent;

varying vec2 vUv;
varying vec3 vNormal;
varying vec3 vTangent;
varying vec3 vBinormal;
varying vec3 vViewPosition;

void main() {
    vUv = uv;

    vNormal = normalize(normalMatrix * normal);
    vTangent = normalize(normalMatrix * tangent.xyz);
    vBinormal = normalize(cross(vNormal, vTangent) * tangent.w);

    vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);
    vViewPosition = -mvPosition.xyz;

    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
}
        </script>
        <script id="fragment_shader" type="x-shader/x-fragment">
uniform sampler2D s_day;
uniform sampler2D s_night;
uniform sampler2D s_normal;

varying vec2 vUv;
varying vec3 vNormal;
varying vec3 vTangent;
varying vec3 vBinormal;
varying vec3 vViewPosition;

void main() {
    vec4 tColor = texture2D(s_day, vUv);
    vec4 tColor2 = texture2D(s_night, vUv);
    vec3 normal_map = (texture2D(s_normal, vUv).xyz * 2.0) - 1.0;
    normal_map.xy *= 0.09;
    normal_map.y = 1.0 - normal_map.y;
    normal_map = normalize(normal_map);

    mat3 tbn = mat3(vTangent, vBinormal, vNormal);

    //vec3 normal = normalize(vNormal);
    vec3 normal = normalize(tbn * normal_map.xyz);
    vec3 lightDir = normalize(vViewPosition);
    //vec3 lightDir = normalize(vec3(1, 0.4, 0.8));

    float dotProduct = dot(normal, lightDir);
    float night = (1.0 - smoothstep(-0.3, 0.1, dotProduct)) * 0.1;
    float day = smoothstep(-0.2, 1.0, dotProduct);
    gl_FragColor = vec4((tColor2.rgb * night) + (tColor.rgb * day), 1.0);
}
        </script>
        <script>
            var scene = new THREE.Scene();
            var camera = new THREE.PerspectiveCamera(
                75, window.innerWidth / window.innerHeight, 0.1, 10);
            var renderer = new THREE.WebGLRenderer();
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(renderer.domElement);

            var day = THREE.ImageUtils.loadTexture('day.jpg');
            var night = THREE.ImageUtils.loadTexture('night.jpg');
            var normal = THREE.ImageUtils.loadTexture('normal.png');
            //var elevation = THREE.ImageUtils.loadTexture('elevation.png');
            //var specular = THREE.ImageUtils.loadTexture('specular.png');

            material = new THREE.ShaderMaterial({
                attributes: {},
                uniforms: {
                    s_day: {type: 't', value: day},
                    s_night: {type: 't', value: night},
                    s_normal: {type: 't', value: normal}
                },
                vertexShader: document.getElementById('vertex_shader').textContent,
                fragmentShader: document.getElementById('fragment_shader').textContent});

            var geometry = new THREE.SphereGeometry(1, 40, 30);
            geometry.computeTangents();
            var globe = new THREE.Mesh(geometry, material);
            scene.add(globe);
            var light = new THREE.DirectionalLight(0xffffff, 1);
            light.position.set(2, 1, 1).normalize();
            scene.add(light);
            camera.position.y = 1.6;
            camera.position.z = 1.6;
            camera.lookAt(scene.position);

            var orbitControls = new THREE.OrbitControls(camera);
            orbitControls.autoRotate = true;
            orbitControls.userPan = false;

            var clock = new THREE.Clock();

            function render() {
                // Time since last frame / seconds
                var delta = clock.getDelta();
                orbitControls.update(delta);

                requestAnimationFrame(render);
                renderer.render(scene, camera);
            }
            render();
        </script>
    </body>
</html>
