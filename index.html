<!DOCTYPE HTML>
<html>
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
        <title>Chez Earth</title>
        <style type="text/css">
            body {
                margin: 0;
                overflow: hidden;
            }
            canvas {
                width: 100%;
                height: 100%;
            }
        </style>
    </head>
    <body>
        <script src="js/three.min.js"></script>
        <script src="js/OrbitControls.js"></script>
        <script id="vertex_shader" type="x-shader/x-vertex">
// Implicit attributes:
//  vec3 position   // The location of the vertex in object coords
//  vec3 normal     // The normal in object frame
//  vec2 uv         // The texture coords
// Implicit uniforms:
//  mat4 projectionMatrix   // From camera to "screen"
//  mat4 modelMatrix        // Object to world
//  mat4 viewMatrix         // World to camera
//  mat4 modelViewMatrix    // Object to camera
//  mat4 projectionmatrix
//  mat3 normalMatrix       // Upper 3x3 of modelViewMatrix (obj -> camera)
//  vec3 cameraPosition
#define N_LIGHTS 2

attribute vec4 tangent;

//struct light {
//    float brightness;
//    vec3 position;  // In world coords.
//};

//uniform light lights[N_LIGHTS];
uniform vec3 light_position;

varying vec2 vUv;
varying vec3 vNormal;
varying vec3 vTangent;
varying vec3 vBinormal;
varying vec3 vSurfaceToEye;
//varying vec3 vLightPositions[N_LIGHTS];
varying vec3 vLightPosition;

void main() {
    vUv = uv;

    vNormal = normalize(normalMatrix * normal);
    vTangent = normalize(normalMatrix * tangent.xyz);
    vBinormal = normalize(cross(vNormal, vTangent) * tangent.w);

    vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);
    vSurfaceToEye = -mvPosition.xyz;

//    for(int i = 0; i < N_LIGHTS; i++) {
//        vLightPositions[i] = (viewMatrix * vec4(lights[i].position, 1.0)).xyz;
//    }
    //vLightPosition = (viewMatrix * vec4(light_position, 1.0)).xyz;
    vLightPosition = (modelViewMatrix * vec4(light_position, 1.0)).xyz;

    gl_Position = projectionMatrix * mvPosition;
}
        </script>
        <script id="fragment_shader" type="x-shader/x-fragment">
uniform sampler2D s_day;
uniform sampler2D s_night;
uniform sampler2D s_normal;
uniform sampler2D s_specular;

struct light {
    float brightness;
    vec3 position;  // In world coords.
};

//#define N_LIGHTS 2
//uniform light lights[N_LIGHTS];
uniform float light_intensity;

varying vec2 vUv;
varying vec3 vNormal;
varying vec3 vTangent;
varying vec3 vBinormal;
varying vec3 vSurfaceToEye;

//varying vec3 vLightPositions[N_LIGHTS];
varying vec3 vLightPosition;

void main() {
    vec4 tColor = texture2D(s_day, vUv);
    vec4 tColor2 = texture2D(s_night, vUv);
    vec3 normal_map = (texture2D(s_normal, vUv).xyz * 2.0) - 1.0;
    normal_map.xy *= 0.05;
    normal_map = normalize(normal_map);
    float kSpecular = texture2D(s_specular, vUv).x * 0.5 + 0.0;

    mat3 tbn = mat3(vTangent, vBinormal, vNormal);

    vec3 normal = normalize(tbn * normal_map.xyz);
    vec3 surfaceToLightDir = normalize(vec3(2.0, 0.3, 1.0));

    float nDotL = dot(normal, surfaceToLightDir);
    // R = the reflection of surfaceToLightDir (L) about the normal
    vec3 R = (2.0 * normal * nDotL) - surfaceToLightDir;
    float rDotV = dot(R, normalize(vSurfaceToEye));
    vec3 specular = vec3(kSpecular * pow(max(0.0, rDotV), 20.0)) * 0.5;
    float night = (1.0 - smoothstep(-0.3, 0.2, nDotL)) * 0.1;
    float day = max(0.0, nDotL);

    vec3 color = (tColor2.rgb * night) + (tColor.rgb * day) + specular;
    //color *= 0.0;

    // light_position: (0, 0, 1.1) -> vLightPosition: (0, -0.0001, -1.5)
    // vSurfaceToEye: (-.9:.9, -.9:.9, 1.6:2.2)
    //  center: (0, 0, 1.6)
    // => surfaceToLightDir = (0, 0, 0.1)
    vec3 surfaceToLight = vSurfaceToEye + vLightPosition;
    float dist = length(surfaceToLight);
    // TODO: Limit range?
    //float intensity = 20.0 * min(0.02 / dist, 1.0);
    float intensity = light_intensity * 0.8 / dist;
    surfaceToLightDir = normalize(surfaceToLight);
    nDotL = dot(normal, surfaceToLightDir);
    color += tColor.rgb * vec3(0.9, 0.9, 1.0) * (max(nDotL, 0.0) * intensity);

    gl_FragColor = vec4(color * 1.5, 1.0);
}
        </script>
        <script id="flash_vertex_shader" type="x-shader/x-vertex">
uniform float time;

varying vec2 vUv;

void main() {
    vUv = uv;

    vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);
    gl_Position = projectionMatrix * mvPosition;
}
        </script>
        <script id="flash_fragment_shader" type="x-shader/x-fragment">
uniform float time;

varying vec2 vUv;

void main() {
    float x = vUv.x - 0.5;
    float y = vUv.y - 0.5;
    float r = (0.25 - (x*x + y*y)) * time;
    gl_FragColor = vec4(r, r, 0.0, 1.0);
}
        </script>
        <script>
            var scene = new THREE.Scene();
            var camera = new THREE.PerspectiveCamera(
                75, window.innerWidth / window.innerHeight, 0.1, 10);
            var renderer = new THREE.WebGLRenderer({antialias: true});
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(renderer.domElement);

            var day = THREE.ImageUtils.loadTexture('day.jpg');
            var night = THREE.ImageUtils.loadTexture('night.jpg');
            var normal = THREE.ImageUtils.loadTexture('normal.png');
            var specular = THREE.ImageUtils.loadTexture('specular.png');

            function getShader(name) {
                return document.getElementById(name).textContent;
            }

            var material = new THREE.ShaderMaterial({
                attributes: {},
                uniforms: {
                    s_day: {type: 't', value: day},
                    s_night: {type: 't', value: night},
                    s_normal: {type: 't', value: normal},
                    s_specular: {type: 't', value: specular},
                    //light_position: {type: '3f', value: [1.0, 2.0, 0.0]}
                    light_position: {type: '3f', value: [0.0, 0.0, 1.1]},
                    light_intensity: {type: 'f', value: 1.0}
                },
                vertexShader: getShader('vertex_shader'),
                fragmentShader: getShader('fragment_shader')
            });

            var radius = 1.0;
            var geometry = new THREE.SphereGeometry(radius, 80, 60);
            geometry.computeTangents();
            var globe = new THREE.Mesh(geometry, material);
            scene.add(globe);

            /*
            geometry = new THREE.PlaneGeometry(0.2, 0.2);
            material = new THREE.MeshBasicMaterial({side: THREE.DoubleSide});
            material = new THREE.ShaderMaterial({
                uniforms: {
                    time: {type: 'f', value: 1.0}
                },
                vertexShader: getShader('flash_vertex_shader'),
                fragmentShader: getShader('flash_fragment_shader'),
                transparent: true,
                blending: THREE.AdditiveBlending
            });
            var plane = new THREE.Mesh(geometry, material);
            plane.position.z = radius * 1.001;
            globe.add(plane);
            */

            camera.position.z = 2.6;
            camera.lookAt(scene.position);

            var orbitControls = new THREE.OrbitControls(camera);
            orbitControls.userPan = false;

            var clock = new THREE.Clock();

            function render() {
                // Time since last frame / seconds
                var delta = clock.getDelta();
                orbitControls.update(delta);
                globe.rotation.y += delta / 4;//0;
                var time = material.uniforms.light_intensity.value;
                if (time > 0.01) {
                    time *= 0.2;
                } else {
                    time = 1.0;
                    var lat = Math.random() * 180 - 90;
                    var lng = Math.random() * 360;

                    var phi = (90 - lat) * Math.PI / 180;
                    var theta = (180 - lng) * Math.PI / 180;

                    var position = material.uniforms.light_position;
                        
                    var r = radius * 1.01;
                    position.value = [r * Math.sin(phi) * Math.cos(theta),
                    r * Math.cos(phi),
                    r * Math.sin(phi) * Math.sin(theta)];
                }
                material.uniforms.light_intensity.value = time;

                requestAnimationFrame(render);
                renderer.render(scene, camera);
            }
            render();
        </script>
    </body>
</html>
